# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'c:\Users\Administrator\Desktop\moon-project\main.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QFileDialog
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from Ui_main import *
import pyqtgraph as pg
import pyqtgraph.opengl as gl
import sqlite3
import os
from lashen import *
from ImageSplit import *
from retinex import *
from vignetting_correction import *
from histogram import *
import cv2
import sys
import OpenGL
import matplotlib.pyplot as plt
import shutil
from qdialogclass import *
from Threadclass import *
from qmygraphicsview import *


#功能文件
# from utils.automaster import bundleAdjustment
from utils.getDescentImageTinyList import getDescentImageTinyListfromOriginData
from imgclass.descentImageClass import DescentImage, load_images_from_folder ,BestDescentImg
from utils.histogramSpecification import  histogramSpecification, histogramSpecificationForList,histogramSpecificationAndMaskForList
from utils.landingSiteTransfer import landingSiteTransfer
from utils.reconstructforDescentImagesandBestBaseImage import convert_colmap_results, convert_txt_and_extract_images
from utils.sieveforBestBaseimgs import match_and_rank_best_images,visualize_matches,image_pair_matching
from utils.sieveforBestBaseimgs import *
from utils.draw_3d import draw_3d, draw_3d_npy




class moonWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.ui=Ui_mainWindow()
        self.ui.setupUi(self)
        with open("./qss/MaterialDark2.qss",'r',encoding='UTF-8') as f:
            qApp.setStyleSheet(f.read())
        self.descendconn=sqlite3.connect(database='img.db')
        self.c = self.descendconn.cursor()
        #数据管理部分
        self.ui.graphicsView.show()
        self.ui.graphicsView_2.show()
        self.ui.pushButton.clicked.connect(self.import_descendimg)
        self.ui.pushButton_2.clicked.connect(self.import_groundimg)
        self.ui.pushButton_3.clicked.connect(self.imgsplit)
        self.ui.radioButton.clicked.connect(self.radio_button_click_1)
        self.ui.radioButton_2.clicked.connect(self.radio_button_click_2)
        self.ui.radioButton_3.clicked.connect(self.radio_button_click_3)
        self.ui.radioButton_4.clicked.connect(self.radio_button_click_4)
        self.ui.radioButton_5.clicked.connect(self.radio_button_click_5)
        self.ui.radioButton_6.clicked.connect(self.radio_button_click_6)
        self.ui.pushButton_14.clicked.connect(self.update_button_click_1)
        self.ui.pushButton_15.clicked.connect(self.update_button_click_2)
        self.ui.lineEdit.setText("2048")
        self.ui.horizontalSlider.valueChanged[int].connect(self.leftshowimg)
        self.ui.horizontalSlider_2.valueChanged[int].connect(self.rightshowimg)
        #设置进度条初始值为0
        self.ui.progressBar.setValue(0)
        #图像预处理部分
        self.ui.pushButton_4.clicked.connect(self.lashen)
        self.ui.pushButton_10.clicked.connect(self.retinex_pretreat)
        self.ui.pushButton_11.clicked.connect(self.vignetting_correction_button_click)
        self.ui.pushButton_12.clicked.connect(self.hist_guide_button_click)
        self.ui.pushButton_13.clicked.connect(self.hist_equal_button_click)
        self.ui.graphicsView_3.show()
        self.ui.graphicsView_4.show()
        self.ui.radioButton_7.clicked.connect(self.radio_button_click_7)
        self.ui.radioButton_8.clicked.connect(self.radio_button_click_8)
        self.ui.horizontalSlider_3.valueChanged[int].connect(self.leftshowimg_2)
        self.prodre=r'D:\moonlocate\pretreat'
        #粗定位部分
        #轨迹重建结果路径
        self.init_graph3d()
        #提示系统进程对话框
        self.dialog=prompot_Dialog()
        self.workplace=r"D:\moonlocate"
        #下降图像路径
        self.inputdir=None
        self.baseimgsdir=os.path.join(self.workplace,r'output\test\baseimgs_split')
        self.outputdir =  os.path.join(self.workplace,"output/test/images2")
        self.textpath =  os.path.join(self.workplace,"output/test/nameOrigin2Tiny2.txt")
        #掩膜图像存储路径
        self.maskpath =  os.path.join(self.workplace,r"data\mask")
        self.height_dir= os.path.join(self.workplace,r"output\visualization\height")
        self.coarse_position_dir=os.path.join(self.workplace,r"output\visualization\coarse_position")
        self.precise_position_dir=os.path.join(self.workplace,r"output\visualization\precise_position")
        #下降图像筛选
        self.ui.pushButton_7.clicked.connect(self.Thread_descentimgselect)
        self.ui.pushButton_21.clicked.connect(self.colmap_reconstruct)
        #循环匹配底图
        self.ui.pushButton_17.clicked.connect(self.cyclic_matching)
        self.ui.pushButton_19.clicked.connect(self.landsite_transfer)
        #着陆点位置传递
        #显示下降高度图
        self.ui.radioButton_10.clicked.connect(self.radio_button_click_10)
        #显示粗定位结果图
        self.ui.radioButton_13.clicked.connect(self.radio_button_click_13)
        self.ui.pushButton_8.clicked.connect(self.trajectory_show)
        self.ui.pushButton_9.clicked.connect(self.coarse_height_show2d)
        self.ui.pushButton_16.clicked.connect(self.update_3d)
        self.ui.graphicsView_5.show()
        #精定位
        #输出控制点的根目录
        self.precise_outdir=os.path.join(self.workplace,r"output\test_precise\cc")
        self.ui.pushButton_5.clicked.connect(self.precise_position)
        self.ui.pushButton_18.clicked.connect(self.extrinsic_estimate)
        self.ui.radioButton_11.clicked.connect(self.radio_button_click_11)
        self.ui.radioButton_12.clicked.connect(self.radio_button_click_12)
        self.ui.pushButton_6.clicked.connect(self.precise_update)
        self.ui.pushButton_20.clicked.connect(self.contrlpoint_reset)
        #控制点选取
        self.scene_1= QtWidgets.QGraphicsScene()
        #显示精定位结果
        self.scene_2= QtWidgets.QGraphicsScene()
        #控制点手动选取提示窗口
        self.contrl_win=contrlpoint_Dialog()
        self.ui.graphicsView_7.sigMousePressPoint.connect(self.slotMousePressPoint)
        self.contrl_win.signal.connect(self.contrlsignal_out)
        self.ui.graphicsView_7.show()
        #着陆点映射
        self.ui.graphicsView_6.sigMousePressPoint.connect(self.GraphMousePressPoint_6)
        self.ui.graphicsView_8.sigMousePressPoint.connect(self.GraphMousePressPoint_8)
        #保存裁剪的小范围底图
        self.smalldom_path=r'D:\moonlocate\output\test\smalldom'
        self.matctpoints_pathor=os.path.join(self.smalldom_path,'or_points.txt')
        self.matctpoints_pathtar=os.path.join(self.smalldom_path,'tar_points.txt')
        self.ui.pushButton_22.clicked.connect(self.tar_imgselect)
        self.ui.pushButton_23.clicked.connect(self.matchpointor_reset)
        self.ui.pushButton_24.clicked.connect(self.matchpointtar_reset)
        self.ui.pushButton_25.clicked.connect(self.match_doms)
        #初始化原始和目标底图的scene大小
        self.scene_or= QtWidgets.QGraphicsScene()
        self.scene_tar= QtWidgets.QGraphicsScene()
        #初始化
        self.attribute_init()
        self.button_init()
        self.show()

        

#重写关闭窗口方法，关闭并清空数据库
  

    def closeEvent(self,event):
        self.descendconn.close()
        self.dialog.close()
        os.remove('img.db')
        event.accept()
#数据导入功能和显示
#图像的文件名保存到数据库中随时索引   
#分割比较慢也放进子线程里  
#没有相应结果时，锁定按钮无法选中

    def attribute_init(self):
        #底图分割重叠比例
        self.df=0
        #底图分割数量
        self.splitcount=0
        #设置底图的坐标转换参数
        self.pcs=None
        self.gcs=None
        self.geotrans=None
        #初始化粗定位输入参数
        #粗定位三维轨迹点的输入路径
        self.cams_path=None
        #保存完整抽帧后的下降图像
        self.descentimgs=None
        #保存粗定位colmap挑选的下降图像
        self.colmap_descentimgs=None
        #保存匹配置信度最高的分割底图
        self.bestbaseimg=DescentImage()
        #保存最佳下降图像,事先实例化
        self.bestdescentimg=DescentImage()
        #初始化bestbaseimg属性
        self.bestbaseimg.set_angle(0)
        self.bestbaseimg.set_name('')
        #初始化bestdescentimg属性
        self.bestdescentimg.set_name('')
        #设置superGlue的匹配阈值
        self.match_threshold=None
        #预设粗定位轨迹输出路径
        self.trajector_dir=None
        #保存粗定位着陆点经纬度
        self.coarse_landsite=[]
        #保存精定位经纬度
        self.precise_landsite=[]
        #保存精定位输出外参路径
        self.cams_path_precise=''
        #保存输入cc的图片实例列表
        self.ccinput_imgs=[]
        #用来保存控制点信息的下降图像序列的实例序列
        self.descentcontrlimgs=[]
        #控制点选取的标志位信号
        self.contrl_signal=True
        #保存下降图像的尺寸用来实例化控制点选取的scene大小
        self.h=None
        self.w=None
        #保存着陆点映射时的图像改变和scene尺寸
        self.dom_or=None
        self.dom_target=None


    def button_init(self):
        #设置lineedit数字显示
        self.ui.lineEdit.setSelection(0,0)
        self.ui.lineEdit_2.setSelection(0,0)
        self.ui.lineEdit_34.setSelection(0,0)
        self.ui.lineEdit_35.setSelection(0,0)
        self.ui.lineEdit_27.setSelection(0,0)
        self.ui.lineEdit_28.setSelection(0,0)
        self.ui.lineEdit_40.setSelection(0,0)
        self.ui.lineEdit_41.setSelection(0,0)
        self.ui.lineEdit_42.setSelection(0,0)
        self.ui.lineEdit_43.setSelection(0,0)
        #锁定底图分割按钮
        self.ui.checkBox.setChecked(False)
        self.ui.checkBox_2.setChecked(False)
        #绑定匹配点选取按钮
        self.ui.checkBox_4.setCheckable(False)
        self.ui.checkBox_5.setCheckable(False)
        self.ui.pushButton_3.setEnabled(False)
        self.ui.pushButton_7.setEnabled(False)
        self.ui.pushButton_21.setEnabled(False)
        self.ui.pushButton_17.setEnabled(False)
        self.ui.pushButton_19.setEnabled(False)
        self.ui.pushButton_14.setEnabled(False)
        self.ui.pushButton_15.setEnabled(False)
        self.ui.pushButton_4.setEnabled(False)
        self.ui.pushButton_12.setEnabled(False)
        self.ui.pushButton_13.setEnabled(False)
        self.ui.pushButton_10.setEnabled(False)
        self.ui.pushButton_11.setEnabled(False)
        self.ui.pushButton_5.setEnabled(False)
        self.ui.pushButton_18.setEnabled(False)
        self.ui.pushButton_20.setEnabled(False)
        self.ui.pushButton_6.setEnabled(False)
        self.ui.pushButton_23.setEnabled(False)
        self.ui.pushButton_24.setEnabled(False)
        self.ui.pushButton_25.setEnabled(False)
        self.ui.radioButton.setEnabled(False)
        self.ui.radioButton_2.setEnabled(False)
        self.ui.radioButton_3.setEnabled(False)
        self.ui.radioButton_4.setEnabled(False)
        self.ui.radioButton_5.setEnabled(False)
        self.ui.radioButton_6.setEnabled(False)
        self.ui.radioButton_7.setEnabled(False)
        self.ui.radioButton_8.setEnabled(False)
        self.ui.radioButton_9.setEnabled(False)
        self.ui.radioButton_10.setEnabled(False)
        self.ui.radioButton_11.setEnabled(False)
        self.ui.radioButton_12.setEnabled(False)
        self.ui.radioButton_13.setEnabled(False)


    def import_descendimg(self):
        self.c.execute("drop table if EXISTS descendimgs")
        self.c.execute("create table descendimgs(id integer primary key autoincrement,imgName TEXT)")
        dir_path = QFileDialog.getExistingDirectory(self, "选择文件夹")
        if os.path.exists(dir_path):
        #降落图像文件夹指定粗定位输入的文件夹
            self.inputdir=dir_path
            #获取文件夹下的所有图片
            file_ls = sorted(os.listdir(dir_path))
            descendimgs = [os.path.join(dir_path, file) for file in file_ls]
            descendimg_0=cv2.imread(descendimgs[0],0)
            #数据管理阶段实例化控制点选取的scene尺寸
            self.h=descendimg_0.shape[0]
            self.w=descendimg_0.shape[1]
            for i in range(len(descendimgs)):
                self.c.execute("insert into descendimgs(id,imgName) values (?,?)",(i+1,descendimgs[i]))
            QMessageBox.information(self, "消息提示", "成功导入"+str(len(descendimgs))+'帧下降图像数据')
            self.ui.radioButton.setEnabled(True)
            self.ui.radioButton_4.setEnabled(True)
            self.ui.radioButton_7.setEnabled(True)
            #这里可能还需要修改
            self.ui.radioButton.setChecked(True)
            self.ui.radioButton_7.setChecked(True)
            #释放数据可视化更新按钮
            self.ui.pushButton_14.setEnabled(True)
            self.ui.pushButton_15.setEnabled(True)
            #设置数据管理界面缺省值
            self.radio_button_click_1()
            #设置预处理显示界面缺省值
            self.radio_button_click_7()
            self.init_coarse_position(len(descendimgs))
        else:
            QMessageBox.information(self, "消息提示", '请输入正确的下降图像路径')

        
        

    def import_groundimg(self):
        self.c.execute("drop table if EXISTS groundimgs")
        self.c.execute("create table groundimgs(id integer primary key autoincrement,imgName TEXT)")
        dir_path = QFileDialog.getExistingDirectory(self, "选择文件夹")
        if os.path.exists(dir_path):
        #获取文件夹下的所有图片
            file_ls = os.listdir(dir_path)
            groundimgs = [os.path.join(dir_path, file) for file in file_ls]
            #这里需要对输入图片排序
            for i in range(len(groundimgs)):
                self.c.execute("insert into groundimgs(id,imgName) values (?,?)",(i+1,groundimgs[i]))
            QMessageBox.information(self, "消息提示", "成功导入"+str(len(groundimgs))+'幅底图数据')
            _,_,_,data = GRID().read_img(groundimgs[0])
            #resize便于显示
            data=cv2.resize(data,(1024,1024))
            scene=self.transform_cv2topix(data,1024,1024)
            self.ui.graphicsView_2.setScene(scene)
            #释放底图分割按钮
            self.ui.pushButton_3.setEnabled(True)
        else:
            QMessageBox.information(self, "消息提示", '请选择正确的底图文件路径')

    def imgsplit(self):
        #全局变量保存底图的投影参考系和地理参考系
        #底图的行列坐标和投影坐标的仿射变换矩阵
        self.splitcount=0
        key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='groundimgs'""").fetchall()
        if key==[]:
            QMessageBox.information(self, "消息提示", "没有底图数据")

        else:
            tiff_path=self.c.execute("SELECT imgName FROM groundimgs").fetchall()[0][0] 
            self.c.execute("drop table if EXISTS groundimgs_split")
            self.c.execute("create table groundimgs_split(id integer primary key autoincrement,imgName TEXT)")
            self.c.execute("drop table if EXISTS groundimgs_complete")
            self.c.execute("create table groundimgs_complete(id integer primary key autoincrement,imgName TEXT)")
        #分割后底图保存的根目录
            dir_path = os.path.join(self.workplace,r'output\test\baseimgs_split')
            dir_path1= os.path.join(self.workplace,r'output\test\baseimgs_complete')
            if os.path.exists(dir_path):
                shutil.rmtree(dir_path,ignore_errors=True)
            os.makedirs(dir_path)
            if os.path.exists(dir_path1):
                shutil.rmtree(dir_path1,ignore_errors=True)
            os.makedirs(dir_path1)
            #设置分割尺寸
            df=int(self.ui.lineEdit.text())
            self.df=df
            pcs,gcs,geotrans,data = GRID().read_img(tiff_path)
            self.pcs=pcs
            self.gcs=gcs
            self.geotrans=geotrans
            overlap=df//2
            height,width = data.shape
            r1=height/overlap
            r2=width/overlap
            data_temp=data.copy()
            data_0=cv2.resize(data_temp,(round(width/r2),round(height/r1)))
            print(data_0.shape)
            # len_1=height//(df//2)
            len_1=height//overlap
            # len_2=width//(df//2)
            len_2=width//overlap
            len=len_1*len_2
            self.ui.progressBar.setMaximum(len)
            self.ui.progressBar.setMinimum(1)
            #裁剪底图
            for i in range(len_1):
                for j in range(len_2):
                    data_1=np.zeros((round(height/r1),round(width/r2),3))
                    #彩色框显示分割范围
                    data_1[:,:,0]=np.copy(data_0)
                    data_1[:,:,1]=np.copy(data_0)
                    data_1[:,:,2]=np.copy(data_0)
                    #判断是否超出边界
                    # h=min(height,(i*(df//2)+df))
                    # w=min(width,(j*(df//2)+df))
                    h=min(height,(i*overlap+df))
                    w=min(width,(j*overlap+df))                    
                    # cur_image = data[i*(df//2):h,j*(df//2):w]
                    cur_image = data[i*overlap:h,j*overlap:w]
                    if cur_image is None:
                        self.ui.progressBar.setValue(i*len_2+j+1)
                        continue
                    else:
                        # cur_image=cur_image+255
                        # q1=(round(j*(df//2)/r2),round(i*(df//2)/r1))
                        q1=(round(j*overlap/r2),round(i*overlap/r1))
                        q2=(round(w/r2),round(h/r1))
                        cv2.rectangle(data_1,q1,q2,(0,0,255),3)
                        #行号
                        formatted_row = "{:03d}".format(i)
                        row=str(formatted_row)
                        #列号
                        formatted_col = "{:03d}".format(j)
                        col=str(formatted_col)
                        completebaseimg_savepath=os.path.join(dir_path1,'complete_'+row+'_'+col+'.png')
                        cv2.imwrite(completebaseimg_savepath,data_1)
                        self.c.execute("insert into groundimgs_complete(id,imgName) values (?,?)",(self.splitcount,completebaseimg_savepath))
                        splitbaseimg_savepath=os.path.join(dir_path,'split_'+row+'_'+col+'.png')
                        cv2.imwrite(splitbaseimg_savepath,cur_image)
                        self.c.execute("insert into groundimgs_split(id,imgName) values (?,?)",(self.splitcount,splitbaseimg_savepath))
                        self.splitcount+=1
                        self.ui.progressBar.setValue(i*len_2+j+1)
            self.ui.lineEdit_2.setText(str(self.splitcount))
            self.ui.radioButton_2.setEnabled(True)
            self.ui.radioButton_3.setEnabled(True)
            self.ui.radioButton_5.setEnabled(True)
            self.ui.radioButton_6.setEnabled(True)
            self.ui.radioButton_8.setEnabled(True)
            self.ui.radioButton_2.setChecked(True)
            self.ui.radioButton_6.setChecked(True)
            #释放下降图像筛选按钮
            self.ui.pushButton_7.setEnabled(True)
            self.ui.pushButton_21.setEnabled(True)
            self.radio_button_click_2()
            self.radio_button_click_6()

            

          

#图片自适应窗口大小
    #直接读入图片为pixmap，只能显示灰度图
    def imgshow(self,img_name):
            scene = QtWidgets.QGraphicsScene()
            scene.setSceneRect(0,0,1024,1024)
            img = QtGui.QPixmap(img_name)
            #图片显示时都调整为1024*1024大小
            img=img.scaled(1024,1024)
            scene.addPixmap(img)
            return scene

    #把cv2读入的图像转化为Qpixmap可以显示的格式，可以显示彩色图
    def transform_cv2topix(self,img,h,w):
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        x = img.shape[1]  
        y = img.shape[0]
        frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
        pix = QPixmap.fromImage(frame)
        scene = QtWidgets.QGraphicsScene()
        scene.setSceneRect(0,0,1024,1024)
        #图片显示时都调整为小于或者等于w*h大小
        pix=pix.scaled(w,h)
        scene.addPixmap(pix)
        return scene 


#滑块控制左侧显示
    def leftshowimg(self,value):
        result=[]
        sys.setrecursionlimit(100000000)
        if self.ui.radioButton.isChecked()==True:
            key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='descendimgs'""").fetchall()
            if key==[]:
                QMessageBox.information(self, "消息提示", "没有下降图像数据")
                result=[]
            else:
                result=self.c.execute("SELECT imgName FROM descendimgs").fetchall() 

        elif self.ui.radioButton_2.isChecked()==True:
            key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='groundimgs_complete'""").fetchall()
            if key==[]:
                QMessageBox.information(self, "消息提示", "没有底图数据")
                result=[]
            else:
                result=self.c.execute("SELECT imgName FROM groundimgs_complete").fetchall()

        elif self.ui.radioButton_3.isChecked()==True:
            key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='groundimgs_split'""").fetchall()
            if key==[]:
                QMessageBox.information(self, "消息提示", "没有分割底图结果")
                result=[]
            else:
                result=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()

        if result!=[]:
                imgs=len(result)
                self.ui.lineEdit_3.setText(str(imgs))
                self.ui.horizontalSlider.setMinimum(1)
                self.ui.horizontalSlider.setMaximum(imgs)
                for i in range(imgs):
                    if value==i+1:
                        self.ui.lineEdit_4.setText(str(i+1))
                        #获取到图像文件名
                        img_name=result[i][0]
                        img=cv2.imread(img_name)
                        scene=self.transform_cv2topix(img,1024,1024)
                        self.ui.graphicsView.setScene(scene)

            

#滑块控制右侧显示              
    def rightshowimg(self,value):
        result=[]
        sys.setrecursionlimit(100000000)
        if self.ui.radioButton_4.isChecked()==True:
            key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='descendimgs'""").fetchall()
            if key==[]:
                QMessageBox.information(self, "消息提示", "没有下降图像数据")
                result=[]
            else:
                result=self.c.execute("SELECT imgName FROM descendimgs").fetchall() 

        elif self.ui.radioButton_5.isChecked()==True:
            key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='groundimgs_complete'""").fetchall()
            if key==[]:
                QMessageBox.information(self, "消息提示", "没有底图数据")
                result=[]
            else:
                result=self.c.execute("SELECT imgName FROM groundimgs_complete").fetchall()

        elif self.ui.radioButton_6.isChecked()==True:
            key=self.c.execute("""
    SELECT name FROM sqlite_master WHERE type='table' AND name='groundimgs_split'""").fetchall()
            if key==[]:
                QMessageBox.information(self, "消息提示", "没有分割地图结果")
                result=[]
            else:
                result=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()

        if result!=[]:
            imgs=len(result)
            self.ui.lineEdit_5.setText(str(imgs))
            self.ui.horizontalSlider_2.setMinimum(1)
            self.ui.horizontalSlider_2.setMaximum(imgs)
            for i in range(imgs):
                if value==i+1:
                    self.ui.lineEdit_6.setText(str(i+1))
                    #获取到图像文件名
                    img_name=result[i][0]
                    img=cv2.imread(img_name)
                    scene=self.transform_cv2topix(img,1024,1024)
                    self.ui.graphicsView_2.setScene(scene)
#单选按钮组的绑定
    def radio_button_click(self,img_list):
        length=len(img_list)
        img_name=img_list[0][0]
        img_0=cv2.imread(img_name)
        scene=self.transform_cv2topix(img_0,1024,1024)
        return length,scene

    def radio_button_click_1(self):
        img_list=self.c.execute("SELECT imgName FROM descendimgs").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_4.setText(str(1))
        self.ui.lineEdit_3.setText(str(length))
        self.ui.horizontalSlider.setValue(1)
        self.ui.graphicsView.setScene(scene)

    def radio_button_click_2(self):
        img_list=self.c.execute("SELECT imgName FROM groundimgs_complete").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_4.setText(str(1))
        self.ui.lineEdit_3.setText(str(length))
        self.ui.horizontalSlider.setValue(1)
        self.ui.graphicsView.setScene(scene)
    
    def radio_button_click_3(self):
        img_list=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_4.setText(str(1))
        self.ui.lineEdit_3.setText(str(length))
        self.ui.horizontalSlider.setValue(1)
        self.ui.graphicsView.setScene(scene)

    def radio_button_click_4(self):
        img_list=self.c.execute("SELECT imgName FROM descendimgs").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_6.setText(str(1))
        self.ui.lineEdit_5.setText(str(length))
        self.ui.horizontalSlider_2.setValue(1)
        self.ui.graphicsView_2.setScene(scene)
    
    def radio_button_click_5(self):
        img_list=self.c.execute("SELECT imgName FROM groundimgs_complete").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_6.setText(str(1))
        self.ui.lineEdit_5.setText(str(length))
        self.ui.horizontalSlider_2.setValue(1)
        self.ui.graphicsView_2.setScene(scene)

    def radio_button_click_6(self):
        img_list=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_6.setText(str(1))
        self.ui.lineEdit_5.setText(str(length))
        self.ui.horizontalSlider_2.setValue(1)
        self.ui.graphicsView_2.setScene(scene)
    
    def radio_button_click_7(self):
        img_list=self.c.execute("SELECT imgName FROM descendimgs").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_11.setText(str(1))
        self.ui.lineEdit_10.setText(str(length))
        self.ui.lineEdit_12.setText(img_list[0][0])
        self.ui.horizontalSlider_3.setValue(1)
        self.ui.graphicsView_3.setScene(scene)
        self.ui.pushButton_4.setEnabled(True)
        self.ui.pushButton_12.setEnabled(True)
        self.ui.pushButton_13.setEnabled(True)
        self.ui.pushButton_10.setEnabled(True)
        self.ui.pushButton_11.setEnabled(True)

    def radio_button_click_8(self):
        img_list=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()
        length,scene=self.radio_button_click(img_list)
        self.ui.lineEdit_11.setText(str(1))
        self.ui.lineEdit_10.setText(str(length))
        self.ui.lineEdit_12.setText(img_list[0][0])
        self.ui.horizontalSlider_3.setValue(1)
        self.ui.graphicsView_3.setScene(scene)
        self.ui.pushButton_4.setEnabled(True)
        self.ui.pushButton_12.setEnabled(True)
        self.ui.pushButton_13.setEnabled(True)
        self.ui.pushButton_10.setEnabled(True)
        self.ui.pushButton_11.setEnabled(True)
#两个更新按钮的功能 
    def update_button_click_1(self):
        if self.ui.radioButton.isChecked()==True:
            img_list=self.c.execute("SELECT imgName FROM descendimgs").fetchall()
        elif self.ui.radioButton_2.isChecked()==True:
            img_list=self.c.execute("SELECT imgName FROM groundimgs_complete").fetchall()
        elif self.ui.radioButton_3.isChecked()==True:
            img_list=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()
        length=len(img_list)
        num=self.ui.lineEdit_4.text()
        num=int(num)
        if num<=0 or num>length:
            QMessageBox.information(self, "消息提示", "请输入正确的图片序号")
        else:
            self.ui.horizontalSlider.setValue(num)
            img_name=img_list[num-1][0]
            img=cv2.imread(img_name)
            scene=self.transform_cv2topix(img,1024,1024)
            self.ui.graphicsView.setScene(scene)
    
    def update_button_click_2(self):
        if self.ui.radioButton_4.isChecked()==True:
            img_list=self.c.execute("SELECT imgName FROM descendimgs").fetchall()
        elif self.ui.radioButton_5.isChecked()==True:
            img_list=self.c.execute("SELECT imgName FROM groundimgs_complete").fetchall()
        elif self.ui.radioButton_6.isChecked()==True:
            img_list=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()
        length=len(img_list)
        num=self.ui.lineEdit_6.text()
        num=int(num)
        if num<=0 or num>length:
            QMessageBox.information(self, "消息提示", "请输入正确的图片序号")
        else:
            self.ui.horizontalSlider_2.setValue(num)
            img_name=img_list[num-1][0]
            img=cv2.imread(img_name)
            scene=self.transform_cv2topix(img,1024,1024)
            self.ui.graphicsView_2.setScene(scene)
    
    

#图像预处理功能和显示
#对比度拉伸
#注意无参数传入时要报错提醒
    def lashen(self):
        if not os.path.exists(self.prodre):
            os.makedirs(self.prodre)
        img_name=self.ui.lineEdit_12.text()
        #读入灰度图处理
        img=cv2.imread(img_name,0)
        #读取拉伸类型
        lashen_str=self.ui.comboBox.currentText()
        #设置gamma拉伸的功能
        if self.ui.checkBox.isChecked()==True:
            gamma=self.ui.lineEdit_9.text()
            if gamma!='':
                gamma=float(gamma)
                img=gamma_trans(img,gamma)
                cv2.imwrite(self.prodre+'\pretreat.jpg',img)
                scene=self.transform_cv2topix(img,1024,1024)
                self.ui.graphicsView_4.setScene(scene)
            else:
                QMessageBox.information(self, "消息提示", "请输入gamma拉伸的参数")
        elif self.ui.checkBox.isChecked()==False and lashen_str=='百分比截断':
            max=self.ui.lineEdit_8.text()
            min=self.ui.lineEdit_7.text()
            if max!='' and min!='':
                max=float(max)
                min=float(min)
                if max>=1 or max<=0:
                    QMessageBox.information(self, "消息提示", "请输入0-1之间的比例")
                elif min>=1 or min<=0:
                    QMessageBox.information(self, "消息提示", "请输入0-1之间的比例")
                else:
                    img=percentage_trans(img,max,min)
                    cv2.imwrite(self.prodre+'\pretreat.jpg',img)
                    scene=self.transform_cv2topix(img,1024,1024)
                    self.ui.graphicsView_4.setScene(scene)
            else:
                QMessageBox.information(self, "消息提示", "请输入百分比截断拉伸所需的参数")
        elif self.ui.checkBox.isChecked()==False and lashen_str=='最大值-最小值':
            max=self.ui.lineEdit_8.text()
            min=self.ui.lineEdit_7.text()
            if max!='' and min!='':
                max=float(max)
                min=float(min)
                if max>255 or max<0:
                    QMessageBox.information(self, "消息提示", "请输入0-255之间的灰度值")
                elif min>255 or min<0:
                    QMessageBox.information(self, "消息提示", "请输入0-255之间的灰度值")
                else:
                    img=min_max_trans(img,max,min)
                    cv2.imwrite(self.prodre+'\pretreat.jpg',img)
                    scene=self.transform_cv2topix(img,1024,1024)
                    self.ui.graphicsView_4.setScene(scene)
            else:
                QMessageBox.information(self, "消息提示", "请输入最大值-最小值拉伸所需的参数")


    def Thread_pretreat_out(self,img_out):
        scene=self.transform_cv2topix(img_out,1024,1024)
        self.ui.graphicsView_4.setScene(scene)
        
    

#retinex图像增强
#未传入参数时提醒
    def retinex_pretreat(self):
        if not os.path.exists(self.prodre):
            os.makedirs(self.prodre)
        dir_path=self.prodre
        img_name=self.ui.lineEdit_12.text()
        #灰度读入
        img=cv2.imread(img_name,0)
        #单尺度retinex算法
        if self.ui.radioButton_19.isChecked()==True:
            sigma=self.ui.lineEdit_16.text()
            if sigma!='':
                sigma=float(sigma)   
                self.Thread_retinex_SSR=Thread_retinex_SSR(img,sigma,dir_path)
                self.Thread_retinex_SSR.signal.connect(self.Thread_pretreat_out)
                #随主线程结束而结束
                self.Thread_retinex_SSR.setDaemon=True
                self.Thread_retinex_SSR.start()
            else:
                QMessageBox.information(self, "消息提示", "请完整输入所需的参数")
         
        #多尺度retinex算法
        elif self.ui.radioButton_20.isChecked()==True:
            sigma_1=self.ui.lineEdit_17.text()
            sigma_2=self.ui.lineEdit_18.text()
            sigma_3=self.ui.lineEdit_19.text()
            if sigma_1!='' and sigma_2!='' and sigma_3!='':
                sigma_1=float(sigma_1)
                sigma_2=float(sigma_2)
                sigma_3=float(sigma_3)
                sigma=[sigma_1,sigma_2,sigma_3]
                self.Thread_retinex_MSR=Thread_retinex_MSR(img,sigma,dir_path)
                self.Thread_retinex_MSR.signal.connect(self.Thread_pretreat_out)
                self.Thread_retinex_MSR.setDaemon=True
                self.Thread_retinex_MSR.start()
            else:
                QMessageBox.information(self, "消息提示", "请完整输入所需的参数")
    #渐晕校正
    def vignetting_correction_button_click(self):
        if not os.path.exists(self.prodre):
            os.makedirs(self.prodre)
        dir_path=self.prodre
        img_name=self.ui.lineEdit_12.text()
        img=cv2.imread(img_name,0)
        self.Thread_vignetting_correction=Thread_vignetting_correction(img,dir_path)
        self.Thread_vignetting_correction.signal.connect(self.Thread_pretreat_out)
        self.Thread_vignetting_correction.setDaemon=True
        self.Thread_vignetting_correction.start()
    #直方图规定化

    def hist_guide_button_click(self):
        #保存预处理图片的路径
        if not os.path.exists(self.prodre):
            os.makedirs(self.prodre)
        dir_path=self.prodre
        filename,ok=QFileDialog.getOpenFileName(self, "选取直方图规定化的目标图片")
        img_name=self.ui.lineEdit_12.text()
        self.Thread_histogram_guide=Thread_histogram_guide(img_name,filename,dir_path)
        self.Thread_histogram_guide.signal.connect(self.Thread_pretreat_out)
        self.Thread_histogram_guide.setDaemon=True
        self.Thread_histogram_guide.start()

    def hist_equal_button_click(self):
        if not os.path.exists(self.prodre):
            os.makedirs(self.prodre)
        dir_path=self.prodre
        img_name=self.ui.lineEdit_12.text()
        hist_equal_str=self.ui.comboBox_2.currentText()
        if hist_equal_str=='全局直方图均衡':
            self.Thread_histogram_equal=Thread_histogram_equal(img_name,dir_path)
            self.Thread_histogram_equal.signal.connect(self.Thread_pretreat_out)
            self.Thread_histogram_equal.setDaemon=True
            self.Thread_histogram_equal.start()
        elif hist_equal_str=='自适应直方图均衡':
            limit=self.ui.lineEdit_20.text()
            gridsize=self.ui.lineEdit_21.text()
            if limit!='' and gridsize!='':
                limit=float(limit)
                gridsize=int(gridsize)
                self.Thread_histogram_equal=Thread_histogram_adaptive_equal(img_name,limit,gridsize,dir_path)
                self.Thread_histogram_equal.signal.connect(self.Thread_pretreat_out)
                self.Thread_histogram_equal.setDaemon=True
                self.Thread_histogram_equal.start()
            else:
                QMessageBox.information(self, "消息提示", "请完整输入所需的参数")
            
           

    def leftshowimg_2(self,value):
        result=[]
        sys.setrecursionlimit(100000000)
        if self.ui.radioButton_7.isChecked()==True:
            result=self.c.execute("SELECT imgName FROM descendimgs").fetchall() 

        elif self.ui.radioButton_8.isChecked()==True:
            result=self.c.execute("SELECT imgName FROM groundimgs_split").fetchall()

        if result!=[]:
                imgs=len(result)
                self.ui.horizontalSlider_3.setMinimum(1)
                self.ui.horizontalSlider_3.setMaximum(imgs)
                for i in range(imgs):
                    if value==i+1:
                        self.ui.lineEdit_11.setText(str(i+1))
                        #获取到图像文件名
                        img_name=result[i][0]
                        self.ui.lineEdit_12.setText(img_name)
                        scene=self.imgshow(img_name)
                        self.ui.graphicsView_3.setScene(scene)
#粗定位功能和显示
#下降图像筛选
    #在下降图像导入时，初始化下降图像筛选的预设参数
    def init_coarse_position(self,len):
        #设置抽帧时是否进行掩膜
        self.match_threshold=0.01
        self.resolution=2.8
        self.ui.checkBox_3.setChecked(True)
        #设置默认的抽帧间隔
        self.ui.lineEdit_29.setText(str(40))
        #设置默认的开始帧数为0，设置默认的结束帧数为最后一帧
        self.ui.lineEdit_23.setText(str(0))
        self.ui.lineEdit_26.setText(str(len))
        #设置重叠比例的阈值
        self.ui.lineEdit_30.setText(str(0.6))
        self.ui.lineEdit_13.setText(str(self.resolution))
        self.ui.lineEdit_22.setText(str(8000))
        self.ui.lineEdit_32.setText(str(self.match_threshold))
        self.ui.lineEdit_33.setText(str(self.match_threshold))
        #提前释放按钮
        self.ui.radioButton_10.setChecked(True)
        #释放循环匹配按钮
        self.ui.pushButton_17.setEnabled(True)
        #释放着陆点传递按钮
        self.ui.pushButton_19.setEnabled(True)
        #释放精定位按钮
        self.ui.pushButton_5.setEnabled(True)
        #释放精定位可视化的更新按钮
        self.ui.pushButton_6.setEnabled(True)
        #释放精定位外参估计按钮
        self.ui.pushButton_18.setEnabled(True)



    def Thread_height_estimation_out(self,out):
        self.descentimgs=out
        self.ui.radioButton_9.setEnabled(True)
        self.ui.radioButton_9.setChecked(True)
        #显示三维轨迹图
        self.trajectory_show()
        self.dialog.setlabel('下降轨迹重建完毕')
        

#三维轨迹点输入路径
    def Thread_height_estimation_3dout(self,out):
        self.cams_path=out
        if self.cams_path!=None:
            self.ui.lineEdit_31.setText(self.cams_path)
#接收colmap重建后挑选的下降图像
    def colmap_img_out(self,out):
        self.colmap_descentimgs=out

    def colmap_reconstruct(self):
        #判断掩膜文件夹maskpath和textpath是否存在
        if not os.path.exists(self.maskpath):
            os.makedirs(self.maskpath)
        inputdir=self.inputdir
        workplace=self.workplace
        beginFrame=self.ui.lineEdit_23.text()
        beginFrame=int(beginFrame)
        endFrame=self.ui.lineEdit_26.text()
        endFrame=int(endFrame)
        howManyFrameBetween=self.ui.lineEdit_29.text()
        howManyFrameBetween=int(howManyFrameBetween)
        OverlapAreaRate=self.ui.lineEdit_30.text()
        OverlapAreaRate=float(OverlapAreaRate)
        mask_signal=self.ui.checkBox_3.isChecked()
        #下降轨迹重建子线程
        self.Thread_colmap_height_estimation=colmap_height_estimation(inputdir,
    workplace,beginFrame,endFrame,howManyFrameBetween,OverlapAreaRate,mask_signal)
        self.Thread_colmap_height_estimation.signal.connect(self.Thread_height_estimation_out)
        self.Thread_colmap_height_estimation.dir_signal.connect(self.Thread_height_estimation_3dout)
        self.Thread_colmap_height_estimation.colmap_img_signal.connect(self.colmap_img_out)
        self.Thread_colmap_height_estimation.setDaemon=True
        self.Thread_colmap_height_estimation.start()
        self.dialog.text_browser.clear()
        self.dialog.setlabel('正在进行下降轨迹重建中，请等待......')
        self.dialog.show()
#接收最佳下降图像实例
    def bestdescentimg_out(self,out):
        #已经规定化
        self.bestdescentimg=out[0]
        #显示最佳下降图像文件名
        self.ui.lineEdit_31.setText(self.bestdescentimg.name)
        self.ui.radioButton_10.setEnabled(True)
        #运行结束之后可以直接显示出高度估计图
        # self.ui.radioButton_10.setChecked(True)
        # #释放循环匹配按钮
        # self.ui.pushButton_17.setEnabled(True)
        # #释放着陆点传递按钮
        # self.ui.pushButton_19.setEnabled(True)
        # #释放精定位按钮
        # self.ui.pushButton_5.setEnabled(True)
        # #释放精定位可视化的更新按钮
        # self.ui.pushButton_6.setEnabled(True)
        # #释放精定位外参估计按钮
        # self.ui.pushButton_18.setEnabled(True)
        # #释放控制点选取按钮
        # self.ui.radioButton_11.setEnabled(True)
        #显示高度估计图
        self.radio_button_click_10()
        self.dialog.setlabel('下降图像筛选完毕')

    def Thread_descentimgselect(self):
        workplace=self.workplace
        height_dir=self.height_dir
        #判断是否存在输出路径
        if not os.path.exists(height_dir):
            os.makedirs(height_dir)
        base_resolution=self.ui.lineEdit_13.text()
        base_resolution=float(base_resolution)
        initHigh=self.ui.lineEdit_22.text()
        initHigh=int(initHigh)
        colmap_descentimgs=self.colmap_descentimgs
        if colmap_descentimgs!=[]:
            self.Thread_descentimg_select=Thread_descentimg_select(workplace,colmap_descentimgs,initHigh,base_resolution,height_dir)
            self.Thread_descentimg_select.signal_bestdescentimg.connect(self.bestdescentimg_out)
            self.Thread_descentimg_select.setDaemon=True
            self.Thread_descentimg_select.start()
            self.dialog.text_browser.clear()
            self.dialog.setlabel('正在进行下降图像筛选中，请等待......')
            self.dialog.show()
        else:
            QMessageBox.information(self, "消息提示", "下降轨迹重建失败，请重新进行下降轨迹重建")



    def Thread_cyclic_matching_bestdescentimg(self,out):
        #更新bestdescentimg属性，可能人为指定
        self.bestdescentimg=out[0]


    def Thread_cyclic_matching_out(self,out):
        self.bestbaseimg=out[0]
        #显示最佳底图的文件名
        self.ui.lineEdit_24.setText(self.bestbaseimg.name)
        #显示最佳底图的旋转角度
        self.ui.lineEdit_39.setText(str(self.bestbaseimg.angle))
        self.dialog.setlabel('循环匹配完毕完毕')


            
    #底图与最佳下降图像循环匹配
    def cyclic_matching(self):

        workplace=self.workplace
        #手动输入最佳下降图像文件名，注意要带后缀名
        bestdescentimg_name=self.ui.lineEdit_31.text()
        bestdescentimg_path=os.path.join(workplace,r'output\test\images2',bestdescentimg_name)
        if not os.path.exists(bestdescentimg_path) or bestdescentimg_name=='':
            QMessageBox.information(self, "消息提示", "请输入正确的下降图像文件名")
        else:
            guide_dir,_=QFileDialog.getOpenFileName(self, "选择直方图规定化的基准图")
            if guide_dir!='':
                #输入未更新之前的bestdescentimg
                bestdescentimg=self.bestdescentimg
                match_threshold=self.ui.lineEdit_33.text()
                match_threshold=float(match_threshold)
                #获取最佳底图文件名,注意无后缀
                self.Thread_cyclic_matching=Thread_cyclic_matching(workplace, bestdescentimg,match_threshold,bestdescentimg_name,guide_dir)
                self.Thread_cyclic_matching.signal.connect(self.Thread_cyclic_matching_out)
                self.Thread_cyclic_matching.signal_bestdescentimg.connect(self.Thread_cyclic_matching_bestdescentimg)
                self.Thread_cyclic_matching.setDaemon=True
                self.Thread_cyclic_matching.start()
                self.dialog.text_browser.clear()
                self.dialog.setlabel('正在进行循环匹配中，请等待......')
                self.dialog.show()
            else:
                QMessageBox.information(self, "消息提示", "请选择正确的规定化目标图片路径")

    
    def Thread_landsite_transfer_out(self,out):
        #目前输出的是经纬度坐标
        self.coarse_landsite=out
        #显示粗定位经纬度
        self.ui.lineEdit_34.setText(str(out[0]))
        self.ui.lineEdit_35.setText(str(out[1]))
        self.dialog.setlabel('着陆点位置传递完毕')
        self.ui.radioButton_13.setEnabled(True)
        self.ui.radioButton_13.setChecked(True)
        #直接显示着陆示意图
        self.radio_button_click_13()

    #接收着陆点位置传递过程的bestbaseimg属性更新信号
    def bestbaseimg_update(self,out):
        #判断是否手动输入了最佳底图
        if out!=[]:
            self.bestbaseimg=out[0]
    
    #接收着陆点位置传递过程的bestdescentimg属性更新信号
    def bestdescentimg_update(self,out):
        #判断是否手动输入了最佳下降图像
        if out!=[]:
            #修改bestdescentimg属性
            self.bestdescentimg=out[0]

    def landsite_transfer(self):
        workplace=self.workplace
        #判断手动输入的底图路径是否正确
        bestbaseimg_name=self.ui.lineEdit_24.text()
        #判断手动输入的最佳下降图像路径是否正确
        bestdescentimg_name=self.ui.lineEdit_31.text()
        bestdescentimg_path=os.path.join(workplace,r'output\test\images2',bestdescentimg_name)
        bestbaseimg_path=os.path.join(workplace,r"output\test\baseimgs_split",bestbaseimg_name+'.png')
        if not os.path.exists(bestdescentimg_path) or bestdescentimg_name=='' :
            QMessageBox.information(self, "消息提示", "请输入正确的下降图像文件名")
        elif not os.path.exists(bestbaseimg_path) or  bestbaseimg_name=='' :
            QMessageBox.information(self, "消息提示", "请输入正确的底图文件名")
        else:
            #若跳过循环匹配阶段，手动输入最佳下降图像和底图直接传递着陆点需要重新规定化
            guide_dir,_=QFileDialog.getOpenFileName(self, "选择直方图规定化的基准图")
            if guide_dir!='':
                bestbaseimg_angle=self.ui.lineEdit_39.text()
                bestbaseimg_angle=int(bestbaseimg_angle)
                bestdescentimg=self.bestdescentimg
                bestbaseimg=self.bestbaseimg
                df=self.df
                pcs=self.pcs
                gcs=self.gcs
                geo=self.geotrans
                position_dir=self.coarse_position_dir
                if not os.path.exists(position_dir):
                    os.makedirs(position_dir)
                match_threshold=self.ui.lineEdit_32.text()
                match_threshold=float(match_threshold)
                self.Thread_landsite_transfer=Thread_landsite_transfer(workplace,bestdescentimg
                                                                    ,bestbaseimg,match_threshold,df,pcs,gcs,geo,position_dir
                                                                    ,bestbaseimg_name,bestbaseimg_angle,bestdescentimg_name,guide_dir)
                self.Thread_landsite_transfer.signal.connect(self.Thread_landsite_transfer_out)
                self.Thread_landsite_transfer.signal_bestbaseimg.connect(self.bestbaseimg_update)
                self.Thread_landsite_transfer.signal_bestdescentimg.connect(self.bestdescentimg_update)
                #随主线程结束
                self.Thread_landsite_transfer.setDaemon=True
                self.Thread_landsite_transfer.start()
                self.dialog.text_browser.clear()
                self.dialog.setlabel('正在进行着陆点位置传递中，请等待......')
                self.dialog.show()
            else:
                QMessageBox.information(self, "消息提示", "请选择正确的规定化目标图片路径")


#3D显示下降轨迹初始化
    def init_graph3d(self):
        self.ui.openGLWidget.show()
        self.ui.openGLWidget.opts['distance'] =20# 初始视角高度
        self.ui.openGLWidget.setWindowTitle('GLScatterPlotItem')  # 定义窗口标题
        g = gl.GLGridItem()
        self.ui.openGLWidget.addItem(g)

    def update_3d(self):
        self.ui.openGLWidget.clear()
        self.init_graph3d()




    
    def trajectory_show(self):
        #读取重建轨迹的三维坐标信息为三个列表x,y,z
        if self.ui.radioButton_9.isChecked()==True:
            path=self.cams_path
            if os.path.exists(path):
                x,y,z=draw_3d_npy(path)
                length=len(x)
                pos=np.zeros((length,3))
                color=np.zeros((length,4))
                size=np.zeros((length))
                for i in range(length):
                    pos[i,:]=[float(x[i]),float(y[i]),-1*float(z[i])]
                    color[i]=[1,0,0,1]
                    size[i]=0.5
                max=round(np.max(pos))
                gl_axis = gl.GLAxisItem()  # 添加xyz坐标轴
                if max<=1000:
                    gl_axis.setSize(1000, 1000, 1000)
                else:
                    gl_axis.setSize(max, max, max)
                self.ui.openGLWidget.addItem(gl_axis)
                
                graph=gl.GLScatterPlotItem(pos=pos, size=size, color=color, pxMode=False)
                
                self.ui.openGLWidget.addItem(graph)
                axisx = gl.GLTextItem()
                axisx.setData(pos=[max/2,0,0],
                            color=[255,0,0],text='X轴', font=QtGui.QFont('Helvetica', 10))
                self.ui.openGLWidget.addItem(axisx)
                axisy = gl.GLTextItem()
                axisy.setData(pos=[0,max/2,0],
                            color=[255,0,0],text='Y轴', font=QtGui.QFont('Helvetica', 10))
                self.ui.openGLWidget.addItem(axisy)
                axisz = gl.GLTextItem()
                axisz.setData(pos=[0,0,max/2],
                            color=[255,0,0],text='Z轴', font=QtGui.QFont('Helvetica', 10))
                self.ui.openGLWidget.addItem(axisz)
            else:
                QMessageBox.information(self, "消息提示", "下降轨迹重建失败")

    def coarse_radio_button_click(self,img_list,h,w):
        length=len(img_list)
        img_name=img_list[0]
        img_0=cv2.imread(img_name)
        scene=self.transform_cv2topix(img_0,h,w)
        return length,scene  

    def radio_button_click_10(self):
        path=self.height_dir
        file_ls = os.listdir(path)
        img_list= [os.path.join(path, file) for file in file_ls]
        length,scene=self.coarse_radio_button_click(img_list,700,700)
        self.ui.lineEdit_14.setText(str(length))
        self.ui.lineEdit_15.setText(str(1))
        self.ui.graphicsView_5.setScene(scene)

    def radio_button_click_13(self):
        path=self.coarse_position_dir
        file_ls = os.listdir(path)
        img_list= [os.path.join(path, file) for file in file_ls]
        length,scene=self.coarse_radio_button_click(img_list,1024,1024)
        self.ui.lineEdit_14.setText(str(length))
        self.ui.lineEdit_15.setText(str(1))
        self.ui.graphicsView_5.setScene(scene)


    def coarse_height_show2d(self):
        if self.ui.radioButton_10.isChecked()==True:
            path=self.height_dir
            file_ls = os.listdir(path)
            height_imgs = [os.path.join(path, file) for file in file_ls]
            img_index=self.ui.lineEdit_15.text()
            img_index=int(img_index)
            img=cv2.imread(height_imgs[img_index-1])
            scene=self.transform_cv2topix(img,700,700)
            self.ui.graphicsView_5.setScene(scene)
        elif self.ui.radioButton_13.isChecked()==True:
            path=self.coarse_position_dir
            file_ls = os.listdir(path)
            position_imgs = [os.path.join(path, file) for file in file_ls]
            img_index=self.ui.lineEdit_15.text()
            img_index=int(img_index)
            img=cv2.imread(position_imgs[img_index-1])
            scene=self.transform_cv2topix(img,1024,1024)
            self.ui.graphicsView_5.setScene(scene)


#精定位
#控制点信号传出
    def contrlsignal_out(self,signal):
        self.contrl_signal=signal

    def precise_position_init(self):
        h=self.h
        w=self.w
        #设置scene尺寸
        self.scene_1.setSceneRect(0,0,w,h)
        self.scene_2.setSceneRect(0,0,w,h)
        #避免多次运行重复问题，类属性要每次重新初始化
        #每次都初始化控制点列表为空，避免列表一直append导致重复(这个问题导致index显示倍数)
        self.descentcontrlimgs=[]
        #实例化
        # for img in self.descentimgs:
        for img in self.ccinput_imgs:
            #数据cv2化，方便后面控制点标定
            #contrl_imgClass类有measure属性
            img_data=img.data.astype(np.uint8)
            contrlimg=contrl_imgClass(img_data,img.name)
            self.descentcontrlimgs.append(contrlimg)
        #释放重置控制点按钮
        self.ui.pushButton_20.setEnabled(True)

    #重置所有控制点
    def contrlpoint_reset(self):
        for contrlimg in self.descentcontrlimgs:
            contrlimg.reset_point()


    def update_contrlpoint(self,index,x0,y0):
        #更新descentcontrlimgs属性
        #设置flag
        self.descentcontrlimgs[index-1].set_flag(self.contrl_signal)
        #设置控制点坐标
        self.descentcontrlimgs[index-1].setpoint(x0,y0)
        #传入图片id，并更新measure属性
        self.descentcontrlimgs[index-1].set_measure(index-1)
        #在data中更新控制点位置显示
        self.descentcontrlimgs[index-1].paint_point()
        #更新显示为标定控制点后的图
        img=self.descentcontrlimgs[index-1].data
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
        x = img.shape[1]  
        y = img.shape[0]
        frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
        pix = QPixmap.fromImage(frame)
        self.scene_1.addPixmap(pix)
        self.ui.graphicsView_7.setScene(self.scene_1)



     
#鼠标点击信号
    def slotMousePressPoint(self,pt):
        ptscene = self.ui.graphicsView_7.mapToScene(pt)  # 把view坐标转换为场景坐标
        x0 = ptscene.x()
        y0 = ptscene.y()
        #显示场景坐标
        self.ui.lineEdit_25.setText(str(x0))
        self.ui.lineEdit_36.setText(str(y0))
        #判断手动选择控制点信号是否选中
        if self.ui.checkBox_2.isChecked() and self.ui.radioButton_11.isChecked():
            #这里需要是模态对话框才可以先修改signal的值
            index=self.ui.lineEdit_38.text()
            #photo id
            index=int(index)
            #修改控制信号
            self.contrl_win.show_dia()
            #更新的控制点measure信息写在contrl_imgClass类内部
            self.update_contrlpoint(index,x0,y0)
     




    def Thread_precise_position_out(self,out):
        self.precise_landsite=out
        self.ui.lineEdit_27.setText(str(out[0]))
        self.ui.lineEdit_28.setText(str(out[1]))
        #着陆点映射界面的经纬度输入
        self.ui.lineEdit_40.setText(str(out[0]))
        self.ui.lineEdit_41.setText(str(out[1]))
        self.dialog.setlabel('精定位完毕')
        #释放精定位结果按钮
        self.ui.radioButton_12.setEnabled(True)
        #选中精定位结果按钮
        self.ui.radioButton_12.setChecked(True)
        #显示精定位结果的第一幅图
        self.radio_button_click_12()

#保存精定位外参估计输出的路径
    def Thread_extrinsic_estimate_out(self,out):
        self.cams_path_precise=out
        self.dialog.setlabel('外参估计完毕')
        #精定位外参估计完之后，释放控制点选取按钮
        self.ui.radioButton_11.setEnabled(True)

    def ccinut_imgs_out(self,out):
        self.ccinput_imgs=out
        #初始化精定位控制点
        #防止colmap挑图后id发生变化，直接用ccinput_imgs来确定控制点的photoid
        self.precise_position_init()

    def extrinsic_estimate(self):
        #输入最佳底图的name，无后缀
        workspacedir=self.workplace
        bestbaseimg_name=self.ui.lineEdit_24.text()
        bestbaseimg_path=os.path.join(workspacedir,r"output\test\bestbaseimg",bestbaseimg_name+'.png')
        if bestbaseimg_name!='' and os.path.exists(bestbaseimg_path):
            workplace=self.workplace
            self.Thread_extrinsic_estimate=Thread_extrinsic_estimate(workplace,bestbaseimg_name)
            self.Thread_extrinsic_estimate.signal.connect(self.Thread_extrinsic_estimate_out)
            self.Thread_extrinsic_estimate.signal_ccimgs.connect(self.ccinut_imgs_out)
            self.Thread_extrinsic_estimate.setDaemon=True
            self.Thread_extrinsic_estimate.start()
            self.dialog.text_browser.clear()
            self.dialog.setlabel('正在进行精定位初始外参估计中，请等待......')
            self.dialog.show()
        else:
            QMessageBox.information(self, "消息提示", "请正确输入底图文件名和旋转角度，并先进行粗定位着陆点传递流程")



    def precise_position(self):
        #创建输出文件夹
        if not os.path.exists(self.precise_outdir):
            os.makedirs(self.precise_outdir)
        #创建精定位图输出文件夹
        if not os.path.exists(self.precise_position_dir):
            os.makedirs(self.precise_position_dir)
        workplace=self.workplace
        #这里输入的bestbaseimg属性是粗定位着陆点传递过程中修改后的
        #如果手动指定过最佳底图，这是对应手动指定的最佳底图
        bestbaseimg=self.bestbaseimg
        #传入contrl_imgClass类方便写入控制点信息
        descentcontrlimgs=self.descentcontrlimgs
        df=self.df
        pcs=self.pcs
        gcs=self.gcs
        geo=self.geotrans
        position_dir=self.precise_position_dir
        contrlsignal=self.ui.checkBox_2.isChecked()
        cams_path=self.cams_path_precise
        if cams_path!='':
            self.Thread_precise_position=Thread_precise_position(workplace,bestbaseimg,
                                                                descentcontrlimgs,df,pcs,gcs,geo,position_dir,contrlsignal,cams_path)
            self.Thread_precise_position.signal.connect(self.Thread_precise_position_out)
            self.Thread_precise_position.setDaemon=True
            self.Thread_precise_position.start()
            self.dialog.text_browser.clear()
            self.dialog.setlabel('正在进行精定位中，请等待......')
            self.dialog.show()
        else:
            QMessageBox.information(self, "消息提示", "请先进行精定位外参估计流程")

#精定位控制点选取和结果可视化
#控制点读入的都是灰度图
#精定位显示的scene要和下降图像尺寸一样，方便控制点选取
    def radio_button_click_11(self):
        img_list=self.descentcontrlimgs
        length=len(img_list)
        self.ui.lineEdit_37.setText(str(length))
        self.ui.lineEdit_38.setText(str(1))
        #获取最后一帧下降图像的data
        #这里需要把data从numpy转化为opencv对象才能显示
        img=img_list[0].data
        img=img.astype(np.uint8)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换图像通道
        x = img.shape[1]  
        y = img.shape[0]
        frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
        pix = QPixmap.fromImage(frame)
        self.scene_1.addPixmap(pix)
        self.ui.graphicsView_7.setScene(self.scene_1)

    def radio_button_click_12(self):
        path=self.precise_position_dir
        file_ls = os.listdir(path)
        img_list= [os.path.join(path, file) for file in file_ls]
        length=len(img_list)
        self.ui.lineEdit_37.setText(str(length))
        self.ui.lineEdit_38.setText(str(1))
        img=cv2.imread(img_list[0])
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换图像通道
        x = img.shape[1]  
        y = img.shape[0]
        frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
        pix = QPixmap.fromImage(frame)
        #把底图变成和scene同样大小显示
        pix=pix.scaled(self.w,self.h)
        self.scene_2.addPixmap(pix)
        self.ui.graphicsView_7.setScene(self.scene_2)

    def precise_update(self):
        if self.ui.radioButton_11.isChecked()==True:
            img_list=self.descentcontrlimgs
            index=self.ui.lineEdit_38.text()
            index=int(index)
            img=img_list[index-1].data
            img=img.astype(np.uint8)
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
            x = img.shape[1]  
            y = img.shape[0]
            frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
            pix = QPixmap.fromImage(frame)
            #size和scene一样方便控制点选取
            self.scene_1.addPixmap(pix)
            self.ui.graphicsView_7.setScene(self.scene_1)

        elif self.ui.radioButton_12.isChecked()==True:
            path=self.precise_position_dir
            file_ls = os.listdir(path)
            img_list= [os.path.join(path, file) for file in file_ls]
            index=self.ui.lineEdit_38.text()
            index=int(index)
            img=cv2.imread(img_list[index-1])
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换图像通道
            x = img.shape[1]  
            y = img.shape[0]
            frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
            pix = QPixmap.fromImage(frame)
            #把底图变成和scene同样大小显示
            pix=pix.scaled(self.w,self.h)
            self.scene_2.addPixmap(pix)
            self.ui.graphicsView_7.setScene(self.scene_2)


#不同分辨率底图之间的定位结果映射
    def GraphMousePressPoint_6(self,pt):
        ptscene = self.ui.graphicsView_6.mapToScene(pt)  # 把view坐标转换为场景坐标
        x0 = ptscene.x()
        y0 = ptscene.y()
        #显示场景坐标
        self.ui.lineEdit_44.setText(str(x0))
        self.ui.lineEdit_45.setText(str(y0))
        if self.ui.checkBox_4.isChecked()==True:
            self.dom_or.add_point(x0,y0)
            self.dom_or.paint_point()
            img=self.dom_or.data
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
            x = img.shape[1]  
            y = img.shape[0]
            frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
            pix = QPixmap.fromImage(frame)
            self.scene_or.addPixmap(pix)
            self.ui.graphicsView_6.setScene(self.scene_or)
            with open(self.matctpoints_pathor, 'w') as f:
                f.write(str(self.dom_or.match_points))



    def GraphMousePressPoint_8(self,pt):
        ptscene = self.ui.graphicsView_8.mapToScene(pt)  # 把view坐标转换为场景坐标
        x0 = ptscene.x()
        y0 = ptscene.y()
        #显示场景坐标
        self.ui.lineEdit_46.setText(str(x0))
        self.ui.lineEdit_47.setText(str(y0))
        if self.ui.checkBox_5.isChecked()==True:
            self.dom_target.add_point(x0,y0)
            self.dom_target.paint_point()
            img=self.dom_target.data
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
            x = img.shape[1]  
            y = img.shape[0]
            frame = QImage(img, x, y,x*3, QImage.Format_RGB888)
            pix = QPixmap.fromImage(frame)
            self.scene_tar.addPixmap(pix)
            self.ui.graphicsView_8.setScene(self.scene_tar)
            with open(self.matctpoints_pathtar, 'w') as f:
                f.write(str(self.dom_target.match_points))

    def matchpointor_reset(self):
        self.dom_or.reset_point()

    def matchpointtar_reset(self):
        self.dom_target.reset_point()

    def tar_imgselect(self):
        if not os.path.exists(self.smalldom_path):
            os.makedirs(self.smalldom_path)
        target_dir,_=QFileDialog.getOpenFileName(self, "选择映射的目标底图")
        bestbaseimg_path=self.ui.lineEdit_24.text()
        #读入最佳底图
        input_path=os.path.join(self.baseimgsdir,bestbaseimg_path+'.png')
        lon_or=self.ui.lineEdit_40.text()
        lat_or=self.ui.lineEdit_41.text()
        if bestbaseimg_path!='' and os.path.exists(input_path):
            if lon_or!='' and lat_or!='':
            #读入原始底图
                dom_or=cv2.imread(input_path,0)
                #实例化原图匹配点
                self.dom_or=matchpoint_Class(dom_or)
                #左侧显示原始最佳底图
                h1,w1=dom_or.shape
                self.scene_or.setSceneRect(0,0,w1,h1)
                dom_or = cv2.cvtColor(dom_or, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
                x = dom_or.shape[1]  
                y = dom_or.shape[0]
                frame_or = QImage(dom_or, x, y,x*3, QImage.Format_RGB888)
                pix_or = QPixmap.fromImage(frame_or)
                self.scene_or.addPixmap(pix_or)
                self.ui.graphicsView_6.setScene(self.scene_or)
                lon_or=float(lon_or)
                lat_or=float(lat_or)
                smalldom_outpath=os.path.join(self.smalldom_path,'smalldom.tif')
                #输出裁剪后的小范围目标底图
                small_tardom=smalldom(lon_or,lat_or,target_dir,smalldom_outpath)
                #实例化小范围目标底图的匹配点对
                self.dom_target=matchpoint_Class(small_tardom)
                #右侧显示目标底图
                h2,w2=small_tardom.shape
                self.scene_tar.setSceneRect(0,0,w2,h2)
                small_tardom = cv2.cvtColor(small_tardom, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
                x = small_tardom.shape[1]  
                y = small_tardom.shape[0]
                frame_tar = QImage(small_tardom, x, y,x*3, QImage.Format_RGB888)
                pix_tar = QPixmap.fromImage(frame_tar)
                self.scene_tar.addPixmap(pix_tar)
                self.ui.graphicsView_8.setScene(self.scene_tar)
                #释放后续操作按钮
                self.ui.checkBox_4.setCheckable(True)
                self.ui.checkBox_5.setCheckable(True)
                self.ui.pushButton_23.setEnabled(True)
                self.ui.pushButton_24.setEnabled(True)
                self.ui.pushButton_25.setEnabled(True)
            else:
                QMessageBox.information(self, "消息提示", "请输入原始底图定位的着陆点经纬度")
        else:
            QMessageBox.information(self, "消息提示", "请输入正确的原始底图文件名")

    def match_doms(self):
        #获取原底图和目标底图标记的匹配点
        pts_src=np.array(self.dom_or.match_points)
        pts_dst=np.array(self.dom_target.match_points)
        img_src=self.dom_or.resetdata
        img_dst=self.dom_target.resetdata
        #计算单应矩阵
        H, mask = cv2.findHomography(np.array(pts_src), np.array(pts_dst), cv2.RANSAC, 5.0)
        result = cv2.warpPerspective(img_src, H, (img_dst.shape[1], img_dst.shape[0]))
        result = 0.5 * img_dst + 0.5 * result
        result = result.astype(np.uint8)
        cat_path=os.path.join(self.smalldom_path,'cat.png')
        cv2.imwrite(cat_path, result)
        #像素几何变换
        xyor_path=os.path.join(self.precise_outdir,'precise_xyor.txt')
        pt_src=np.loadtxt(xyor_path)
        pt_src=np.append(pt_src,1.0).reshape(3,1)
        pt_dst = np.dot(H, pt_src)
        pt_dst = pt_dst / pt_dst[-1]
        #col=x,row=y
        x_tar = pt_dst[0][0]
        y_tar= pt_dst[1][0]
        xytar_path=os.path.join(self.smalldom_path,'xytar.txt')
        with open(xytar_path,'w') as f:
            f.write(str(x_tar)+" "+str(y_tar))
        #用裁剪后1024*1024目标底图计算映射经纬度
        smalldom_path=os.path.join(self.smalldom_path,'smalldom.tif')
        #y=row,x=col
        lon_tar,lat_tar=cal_lonlat(smalldom_path,y_tar,x_tar)
        lon_tar=format(lon_tar,'.6f')
        lat_tar=format(lat_tar,'.6f')
        #显示映射后的经纬度信息
        self.ui.lineEdit_42.setText(str(lon_tar))
        self.ui.lineEdit_43.setText(str(lat_tar))
        position_path=os.path.join(self.smalldom_path,'lonlat_tar.txt')
        #输出映射后的像素坐标
        #输出映射后的经纬度
        with open(position_path,'w') as f:
            f.write(str(lon_tar)+" "+str(lat_tar))
        tar_imgout= np.expand_dims(img_dst,2)
        tar_imgout=np.repeat(tar_imgout,3,2)
        cv2.circle(tar_imgout,(int(x_tar),int(y_tar)),5,(0,0,255),-1)
        cv2.putText(tar_imgout, "[{},{}]".format(lon_tar,lat_tar),(int(x_tar),int(y_tar))
                    ,cv2.FONT_HERSHEY_TRIPLEX, 1, (0, 0, 255))
        #输出路径
        tarimg_outpath=os.path.join(self.smalldom_path,'tar_position.png')
        cv2.imwrite(tarimg_outpath,tar_imgout)
        #在右侧显示映射结果图
        tar_imgout = cv2.cvtColor(tar_imgout, cv2.COLOR_BGR2RGB)  # 转换3图像通道便于显示
        x = tar_imgout.shape[1]  
        y = tar_imgout.shape[0]
        frame_tar = QImage(tar_imgout, x, y,x*3, QImage.Format_RGB888)
        pix_tar = QPixmap.fromImage(frame_tar)
        self.scene_tar.addPixmap(pix_tar)
        self.ui.graphicsView_8.setScene(self.scene_tar)

        
    
    





            




  

if __name__=='__main__':
    app = QtWidgets.QApplication(sys.argv)
    win=moonWindow()
    sys.exit(app.exec_())


